/**
 * @author Administrator
 *
 */
package com.localhost.part10.Hash;

/**
 * 散列是一种用以实现信息存储和快速检索的技术。准确说将关键字映射到存储位置的过程称为散列。
 * 
 * 散列包含4个主要部分：
 * 1.散列表
 * 2.散列函数
 * 3.冲突
 * 4.冲突的解决技术
 * 
 * 散列表(hash table)
 * 散列表是数组的一个推广。在数组中，关键字k的元素将存储到数组的位置k。这就意味着，给定一个关键字k，仅通过查看数组的第k个位置就可以找到该元素，这称为直接寻址。
 * 假设没有足够的空间来为每一个关键字分配位置，那么就需要一个机制来处理这种情况。一种解决方案就是使用散列表。
 * 散列表或散列映射是一种数据结构，用以存储关键字以及其关联的值。散列表利用散列函数将关键字映射到其关联的值。
 * 
 * 散列函数(hash function)
 * 散列函数用于将关键字转换成索引。
 * 好的散列函数的特征
 * 1.最大限度减少冲突
 * 2.简单并快速计算
 * 3.将键值(key value)在散列表中均匀分布
 * 4.能使用关键字提供所有信息
 * 5.对一组给定的关键字具有一个高负载因子(load factor)
 * 
 * 负载因子(load factor)
 * 一个非空的散列表的负载因子是存储在表中的元素个数除以表的长度。
 * 负载因子 = 散列表中的元素个数 / 散列表的长度
 * 
 * 冲突(collision)
 * 散列函数用于将每个关键字映射到不同的地址空间，但当无法创建一个为每个关键字银蛇到不同地址空间的散列函数时就称为发生了冲突。
 * 冲突是指两个关键字存储到相同位置的情况。
 * 
 * 冲突解决技术
 * 寻找替代位置的过程就是冲突解决。常用的方法是直接链接法和开放定址法。
 * 直接链接法：链表数组的应用
 * 	分离链表法
 * 开放定址法：基于数组的实现
 * 	线性探测法(线性搜索)
 *  二次探测法(非线性搜索)
 *  双重散列法(使用两个散列函数)
 *  
 * 分离链表法
 * 基于链接法的冲突解决方案是将散列表与链表形式结合来实现。当两个或多个记录散列到相同的位置时，这些记录将构成一个单向链表，称为链。
 * 
 * 开放定址法：所有关键字存储在散列表自身中，这种方法也称为闭散列法。该过程是基于探测的，即通过探测来解决冲突。
 * 线性探测法：
 * 	探测建个固定值1。在线性探测中，从发生冲突的原始位置开始顺序搜索散列表。如果表中的某个位置被占用，则查找下一个位置。
 *  必要时还可以从表的最后一个位置循环到表中的第一个位置进行搜索。用于再次散列的函数如下：
 *  	rehash(key) = (n + 1) % tablesize
 *  线性探测的一个问题是，表项往往在散列表中聚集，即散列表包含一组连续的被占据的位置，这一现象就称为聚集。
 *  
 * 二次探测法
 * 	聚集问题可以使用二次探测法消除。在二次探测法中，从发生冲突初始位置i开始，如果某个位置被占据，则探测i+1^2、i+2^2、i+3^2、i+4^2等位置。
 *  必要时还可以从表的最后一个位置循环到表中的第一个位置进行搜索。用于再次散列的函数如下：
 *  	rehash(key) = (n + k^2) % tablesize
 *  二次探测法还是存在出现集聚的可能。
 *  
 *  双重散列法
 *   由于探测序列的增量使用第二个散列函数计算，所以第二个散列函数h2应遵循：
 *   		h2(key) != 0  且 h2 != h1
 *   算法首先探测位置h1(key).若该位置被占据，那么继续探测位置 h1(key)+h2(key)、h1(key)+2*h2(key)、......
 */

















